# 二叉树的节点
> 二叉树节点含有一个`信息成员`,两个`指针成员`指向其左右节点。因此BSTNode类的成员声明为public,因为他们只能由BST类型的非公有成员访问，这样信息隐藏的原则得到了遵守。

代码如下:
```c++
#include<iostream>
using namespace::std;

#ifndef _GENBST_H
#definf _GENBST_H	
template<class T>
class BSTnode{
public:
	BSTnode=default;
	BSTnode(const T&val,BSTnode	*l=0,BSTnode	*r=0):value(val),left(l),right(r){}
	T value;
	BSTnode	*left,*right;
};

template<class T>
class BST{
public:
	BST()=default;
	BST(BSTnode	*root):root(root){}
	~BST(){clear();}
	bool empty()const{return root==0;}
	void preorder(){ preorder(root);}
	void inorder(){inorder(root);}
	void postorder(){postorder(root);}
	T* search(const T&el)const{return search(root,el);}

	void breadthfirst();
	void MorrisInorder();
	void insert(const T&);
	void deleteByMerging(BSTnode<T>*&);
	void deleteByCopying(BSTnode<T>*&);
	void balance(T*,int,int);
protected:
	BSTnode	*root;
	void clear(BSTnode<T>*);
	T& search(BSTnode<T>*,const T&)const;
	void preorder(BSTnode<T>*);
	void inorder(BSTnode<T>*);
	void postorder(BSTnode<T>*);
	virtual visit(BSTnode<T>*root)const{		cout<<root->value<<' ';
	}
};
//virtual protected;
#endif
```

# 二叉树的查找
> 由于二叉树的排列规律，查找是非常简洁明了的。从头部开始，所找的值比节点值大就去左支找，小了就去右支找。直到叶尾。
```c++
#include "genBST.h"
using namespace::std;

template<class T>
T* search (genBST<T>* p,const T& val){
  while(p!=0){
    if(p->value==val)
	return p->value;
    else if(p->value<val)
	p=p->right;
    else p=p->left;
  }
  return 0;//给一个指针赋0意味着没找到
}
```
性能分析:复杂度由比较次数决定，比较次数由树的形状和点在树中的位置决定。内部路径长度(IPL)表示所有节点所有路径长度的总和，对于高度为h的树，n=2^h-1,IPL=Σ(i-1)* L(i).L(i)表示i层的节点数
> 在最坏的情况下 树退化成链表，path(worst)=IPL/n=(n-1)/2=O(n)。 
>
> 在最好情况下，树是接近于完全二叉树的。 path(best)=IPL/n={Σ(i-1)* 2^(i-1)} / (2^h-1) ≈lg(n+1)-2=O(log(n))
>
> 计算和经验都表明 查找算法更接近于最好情况，但这只针对随机创建的树，如果高度不平衡就接近于最坏情况

# 二叉树的遍历
> 树的遍历就是访问树中每个节点仅一次的过程。对于n节点的树，有n!种不同的遍历方式，而真正有规律的只有几种。

1. 广度优先遍历
这种遍历方式从上到下，从左到右，逐层的访问元素。我们用queue实现。
```c++
#include<iostream>
#include<queue>
using namespace::std;

template<class T>
void BST::breadthfirst(){
  queue<T> q1;
  BSTnode<T>* p=root;
  if(p){
    q1.push(p);
    while(!q1.empty()){
	p=q1.top();
	q1.pop():
	visit(p);
	if(p->left) q1.push(p->left);
	else if(p->right) q1.push(p->right);
   }
 }
}
```
# 二叉树的插入
# 二叉树的删除
# 二叉树的平衡
