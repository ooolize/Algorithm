# Singly-Linked-List 的实现
---
> 链表节点实现包括储存的值以及指向下一个节点的指针（public)
>
> 链表的实现思路是用两个指针确定首尾（head,tail）,还有一些成员函数用于更新链表#

头文件如下：
**Singly-Linked-List.h**
```c++
#include<iostream>
using namespace::std;

class SLLNode{
public:
	SLLNode()=default;
	SLLNode(int value,SLLNode* next=0):value(value),next(next){}
	int value;
	SLLNode* next;
};
class SLLList{
public:
	SLLList()=default;
	SLLList(SLLList* head=0,SLLList* tail=0):head(head),tail(tail){}
	~SLLList();
	bool IsEmpty(){return tail==head;}  //表是空的吗
	bool IsInList(const int& val);      //值是否在表中
	void AddToHead(const int& val);     //从首部加节点
	void AddToTail(const int& val);     //从尾部加节点
	void DeleteNode(int val);           //删除一个节点
	int DeleteHead();                   //从头部删除
	int DeleteTail();                   //从尾部删除

private:
	SLLList* head;
	SLLList* tail;

};
```
源程序如下：
```c++
**Singly-Linked-List.cpp**
#include <iostream>
#include "Singly-linked List.h"

SLLList::~SLLList(){
	for(SLLNode* tmp=head;!IsEmpty();head=head->next){
		delete tmp;
		tmp=head;
	}
}
//经验:凡是那些删除之后还要使用原来的，需要留一个拷贝。
bool SLLList::IsInList(const int& val){
	SLLNode* tmp=head;
	for(;tmp!=0&&tmp->value!=val;tmp=tmp->next)
	return tmp!=0;
}

void  SLLList::AddToTail(const int& val){
	if(tail!=0)
		tail->next=new SLLNode(val);			          //节点的建立 与链表的联系
		tail=tail->next;
	else
		head=tail=new SLLNode(val);
}
void SLLList::AddToHead(const int& val){        //不用中间变量，看看这
	if(tail!=0){								                  //void SLLList::AddToHead(const int & val){
		SLLNode* tmp=new SLLNode(val);		        	// head=new SLLNode(val,head)
		tmp->next=head;							                //	if(tail==0) head=tail;
		head=tmp;							                    	//}
	}
	else
		head=tail=new SLLNode(val);
}
void SLLList::DeleteNode(const int& val){
	if(tail!=0){ 								               //有元素
		if(tail==head&&tail->value==val){		    //有一个正好是要找的
			delete tail;
			head=tail=0;
		}
		else if(tail!=head&&head->value==val){	//至少有一个而且头部就是要找的
			SLLNode* tmp=head;
			head=head->next;
			delete tmp;
		}
		else{									                  //至少有一个但不在头部
			SLLNode* pred=head,tar=head->next;
			for(;tar!=tail&&tar->value==val;pred=pred->next,tar=->tar->next);
			if(tar!=0){							              //如果可以找见							
				pred->next=tar->next;			          //无论是在中间或者尾部总成立
				if(tar==tail)					              //如果在尾部就要删除尾部 更新tail
					tail=pred;
			delete tar;
		}
	}
}
int& SLLList::DeleteTail(){
	int ans=tail->value;
	if(tail==head){
		delete tail;
		tail=head=0;
	}
	else{
		SLLNode* tmp=head;
		for(;tmp->next!=tail;tmp=tmp->next)
		tmp->next=0;
		delete tail;		
		tail=tmp;
	}
	return ans;
}
int &SLLList::DeleteHead(){
	int ans=head->value;
	SLLNode* tmp=head;
	if(tail==head) tail=head=0;
	else head=head->next;
	delete tmp;
	}
}
```
